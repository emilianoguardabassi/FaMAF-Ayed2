### Ejercicio 1

1. Implementá el TAD Pila utilizando la siguiente representación:

implement Stack of T where

type Stack of T = List of T

constructors
    fun empty_stack() ret s : Stack of T
        s:=empty()
    end fun

    proc push (in e : T, in/out s : Stack of T)
        addl(s,e)
    end proc

operations
    fun is_empty_stack(s : Stack of T) ret b : Bool
        b:=is_empty(s)
    end fun

    {- PRE: not is_empty_stack(s) -}
    fun top(s : Stack of T) ret e : T
        e:=head(s)
    end fun

    {- PRE: not is_empty_stack(s) -}
    proc pop (in/out s : Stack of T)
        tail(s)
    end proc

### Ejercicio 2

Implementá el TAD Pila utilizando la siguiente representación:

implement Stack of T where

type Node of T = tuple
    elem : T
    next : pointer to (Node of T)
    end tuple

type Stack of T = pointer to (Node of T)


constructors
    fun empty_stack() ret s : Stack of T
        s:=null
    end fun

    proc push (in e : T, in/out s : Stack of T)
        var aux: pointer to (Node of T)
        alloc(aux)
        aux->elem := e 
        aux->next := s 
        s:=aux 
    end proc

operations
    fun is_empty_stack(s : Stack of T) ret b : Bool
        b:= s=null
    end fun

    {- PRE: not is_empty_stack(s) -}
    fun top(s : Stack of T) ret e : T
        e:=s->elem
    end fun

    {- PRE: not is_empty_stack(s) -}
    proc pop (in/out s : Stack of T)
        var aux: pointer to (Node of T)
        aux:=s 
        s:=s->next
        free(aux)
    end proc



### Ejercicio 3

Completá la implementación del tipo Árbol Binario dada en el teórico, donde utilizamos la siguiente
representación:

implement Tree of T where

type Node of T = tuple
    left: pointer to (Node of T)
    value: T
    right: pointer to (Node of T)
    end tuple

type Tree of T= pointer to (Node of T)

constructors
    fun empty_tree() ret t : Tree of T
        t:=null
    end fun

    fun node (tl : Tree of T, e : T, tr : Tree of T) ret t : Tree of T
        alloc(t)
        t->left:=tl
        t->value:=e 
        t->right:=tr
    end fun

operations
    fun is_empty_tree(t : Tree of T) ret b : Bool
        b:= t=null
    end fun

    fun root(t : Tree of T) ret e : T
        e:=t->e
    end fun
    {- PRE: not is_empty_tree(t) -}

    fun left(t : Tree of T) ret tl : Tree of T
        tl:=t->left
    end fun
    {- PRE: not is_empty_tree(t) -}
    
    fun right(t : Tree of T) ret tl : Tree of T
        tr:=t->right
    end fun
    {- PRE: not is_empty_tree(t) -}

    fun height(t : Tree of T) ret n : Nat
    {- Devuelve la distancia que hay entre la raíz de t
    y la hoja más profunda. -}
    
    fun is_path(t : Tree of T, p : Path) ret b : Bool
    {- Devuelve True si p es un camino válido en t -}

    fun subtree_at(t : Tree of T, p : Path) ret t0 : Tree of T
    {- Devuelve el subárbol que se encuentra al recorrer
    el camino p en t . -}

    fun elem_at(t : Tree of T, p : Path) ret e : T
    {- Devuelve el elemento que se encuentra al recorrer
    el camino p en t . -}
    {- PRE: is_path(t,p) -}

