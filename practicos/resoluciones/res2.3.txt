### Ejercicio 1

1. Implementá el TAD Pila utilizando la siguiente representación:

implement Stack of T where

type Stack of T = List of T

constructors
    fun empty_stack() ret s : Stack of T
        s:=empty()
    end fun

    proc push (in e : T, in/out s : Stack of T)
        addl(s,e)
    end proc

operations
    fun is_empty_stack(s : Stack of T) ret b : Bool
        b:=is_empty(s)
    end fun

    {- PRE: not is_empty_stack(s) -}
    fun top(s : Stack of T) ret e : T
        e:=head(s)
    end fun

    {- PRE: not is_empty_stack(s) -}
    proc pop (in/out s : Stack of T)
        tail(s)
    end proc

### Ejercicio 2

Implementá el TAD Pila utilizando la siguiente representación:

implement Stack of T where

type Node of T = tuple
    elem : T
    next : pointer to (Node of T)
    end tuple

type Stack of T = pointer to (Node of T)


constructors
    fun empty_stack() ret s : Stack of T
        s:=null
    end fun

    proc push (in e : T, in/out s : Stack of T)
        var aux: pointer to (Node of T)
        alloc(aux)
        aux->elem := e 
        aux->next := s 
        s:=aux 
    end proc

operations
    fun is_empty_stack(s : Stack of T) ret b : Bool
        b:= s=null
    end fun

    {- PRE: not is_empty_stack(s) -}
    fun top(s : Stack of T) ret e : T
        e:=s->elem
    end fun

    {- PRE: not is_empty_stack(s) -}
    proc pop (in/out s : Stack of T)
        var aux: pointer to (Node of T)
        aux:=s 
        s:=s->next
        free(aux)
    end proc



### Ejercicio 3

Completá la implementación del tipo Árbol Binario dada en el teórico, donde utilizamos la siguiente
representación:

implement Tree of T where

type Node of T = tuple
    left: pointer to (Node of T)
    value: T
    right: pointer to (Node of T)
    end tuple

type Tree of T= pointer to (Node of T)

constructors
    fun empty_tree() ret t : Tree of T
        t:=null
    end fun

    fun node (tl : Tree of T, e : T, tr : Tree of T) ret t : Tree of T
        alloc(t)
        t->left:=tl
        t->value:=e 
        t->right:=tr
    end fun

operations
    fun is_empty_tree(t : Tree of T) ret b : Bool
        b:= t=null
    end fun

    fun root(t : Tree of T) ret e : T
        e:=t->e
    end fun
    {- PRE: not is_empty_tree(t) -}

    fun left(t : Tree of T) ret tl : Tree of T
        tl:=t->left
    end fun
    {- PRE: not is_empty_tree(t) -}
    
    fun right(t : Tree of T) ret tl : Tree of T
        tr:=t->right
    end fun
    {- PRE: not is_empty_tree(t) -}

    fun height(t : Tree of T) ret n : Nat
        if is_empty_tree(t) then 
            n:=0
        else
            n:= 1 + max(height(left(t)),height(right(t)))
        fi
    end fun
    
    fun is_path(t : Tree of T, p : Path) ret b : Bool
        var aux: Tree of T
        aux := t
        b := true

        for i := 1 to length(p) do
            if is_empty_tree(aux) then
                b := false
                break
            fi
            if p[i] = "L" then
                aux := left(aux)
            else if p[i] = "R" then
                aux := right(aux)
            else
                b := false
                break
            fi
        od
    end fun

    fun subtree_at(t : Tree of T, p : Path) ret t0 : Tree of T
        var aux: Tree of T
        aux := t
        for i := 1 to length(p) do
            if is_empty_tree(aux) then
                aux := NULL
            fi
            if p[i] = "L" then
                aux := left(aux)
            else if p[i] = "R" then
                aux := right(aux)
            else
                t0 := NULL
                return
            fi
        od
        t0 := aux
    end fun

    fun elem_at(t : Tree of T, p : Path) ret e : T
        var aux: Tree of T
        aux := subtree_at(t, p)
        if is_empty_tree(aux) then
            error("El camino no es válido.")
        fi
        e := root(aux)
    end fun
    {- PRE: is_path(t,p) -}

### Ejercicio 5 

Un Diccionario es una estructura de datos muy utilizada en programación. Consiste de una colección
de pares (Clave,Valor), a la cual le puedo realizar las operaciones:

• Crear un diccionario vacı́o.

• Agregar el par consistente de la clave k y el valor v. En caso que la clave ya se encuentre en el
diccionario, se reemplaza el valor asociado por v.

• Chequear si un diccionario es vacı́o.

• Chequear si una clave se encuentra en el diccionario.

• Buscar el valor asociado a una clave k. Solo se puede aplicar si la misma se encuentra.

• Una operación que dada una clave k, elimina el par consistente de k y el valor asociado. Solo se
puede aplicar si la clave se encuentra en el diccionario.

• Una operación que devuelve un conjunto con todas las claves contenidas en un diccionario.

(a)
Especificá el TAD diccionario indicando constructores y operaciones.

spec Dict of (K,V) where
donde K y V pueden ser cualquier tipo, asegurando que K tenga definida una función que chequea
igualdad.

(b) Implementá el TAD diccionario utilizando la siguiente representación:

implement Dict of (K,V) where

type Node of (K,V) = tuple
    left: pointer to (Node of (K,V))
    key: K
    value: V
    right: pointer to (Node of (K,V))
    end tuple

    type Dict of (K,V)= pointer to (Node of (K,V))

Como invariante de representación debemos asegurar que el árbol representado por la estructura
sea binario de búsqueda de manera que la operación de buscar un valor tenga orden logarı́tmico.
Es decir, dado un nodo n, toda clave ubicada en el nodo de la derecha n.right, debe ser mayor o
igual a n.key. Y toda clave ubicada en el nodo de la izquierda n.left, debe ser menor a n.key.
Debes tener especial cuidado en la operación que agrega pares al diccionario.


Resoluciones:

a) 

spec Dict of (K,V) where

constructors

    fun emptydic() ret d: Dict
    {-crea un diccionario vacío-}

    proc add_dict(in/out d:dict, in k: T, in v:T)
    {-Agrega un par consistente de la clave k y el valor v.
    En caso de que la clave ya se encuentre en el diccionario,
    se reemplaza el valor asociado v-}

operations

    fun is_dict_empty(d:dict) ret b:bool
    {-Se fija si el diccionario está vacío-}

    fun is_key_there(d:dict, k:T) ret b:bool
    {-Se fija si la clave k se encuentra en el diccionario-}

    fun search_value(d:dict,k:t) ret v:T
    {-Busca el valor asociado a una clave k-} 
    {-PRE: Solo se puede aplicar si la misma se encuentra-}

    proc delete_pair(in/out d:dict, in k:T)
    {-Una operación que dada una clave k, elimina el par 
    consistente de k y el valor asociado-}
    {-PRE: Solo se puede aplicar si la clave se encuentra 
    en el diccionario-}

    fun dict_to_set(d:dict) ret s:set
    {-Una operación que devuelve un conjunto con todas 
    las claves contenidas en un diccionario-}


b)

implement Dict of (K,V) where

type Node of (K,V) = tuple 
    left: pointer to (Node of (K,V))
    key:K 
    value:V
    right: pointer to (Node of (K,V))
    end tuple

type Dict of (K,V) = pointer to (K,V)

constructors

    fun emptydic() ret d: Dict
        d:=null
    end fun

    proc add_dict(in/out d:dict, in k: T, in v:T)
        var aux: pointer to (K, V)
        var parent: pointer to (K, V)

        // Caso: Árbol vacío
        if d = NULL then
            alloc(d)
            d->left := NULL
            d->key := k
            d->value := v
            d->right := NULL
        else
            // Caso: Árbol no vacío
            aux := d
            parent := NULL

            while aux != NULL do
                parent := aux
                if k = aux->key then
                    // Si la clave ya existe, reemplazamos el valor
                    aux->value := v
                    return
                fi
                if k < aux->key then
                    aux := aux->left
                else
                    aux := aux->right
                fi
            od

            // Crear el nuevo nodo
            alloc(aux)
            aux->left := NULL
            aux->key := k
            aux->value := v
            aux->right := NULL

            // Conectar el nuevo nodo al árbol
            if k < parent->key then
                parent->left := aux
            else
                parent->right := aux
            fi
        fi
    end proc
    {-Agrega un par consistente de la clave k y el valor v.
    En caso de que la clave ya se encuentre en el diccionario,
    se reemplaza el valor asociado v-}

operations

fun is_dict_empty(d:dict) ret b:bool
{-Se fija si el diccionario está vacío-}

fun is_key_there(d:dict, k:T) ret b:bool
{-Se fija si la clave k se encuentra en el diccionario-}

fun search_value(d:dict,k:t) ret v:T
{-Busca el valor asociado a una clave k-} 
{-PRE: Solo se puede aplicar si la misma se encuentra-}

proc delete_pair(in/out d:dict, in k:T)
{-Una operación que dada una clave k, elimina el par 
consistente de k y el valor asociado-}
{-PRE: Solo se puede aplicar si la clave se encuentra 
en el diccionario-}

fun dict_to_set(d:dict) ret s:set
{-Una operación que devuelve un conjunto con todas 
las claves contenidas en un diccionario-}




