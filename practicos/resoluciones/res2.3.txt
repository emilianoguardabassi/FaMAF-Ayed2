### Ejercicio 1

1. Implementá el TAD Pila utilizando la siguiente representación:

implement Stack of T where

type Stack of T = List of T

constructors
    fun empty_stack() ret s : Stack of T
        s:=empty()
    end fun

    proc push (in e : T, in/out s : Stack of T)
        addl(s,e)
    end proc

operations
    fun is_empty_stack(s : Stack of T) ret b : Bool
        b:=is_empty(s)
    end fun

    {- PRE: not is_empty_stack(s) -}
    fun top(s : Stack of T) ret e : T
        e:=head(s)
    end fun

    {- PRE: not is_empty_stack(s) -}
    proc pop (in/out s : Stack of T)
        tail(s)
    end proc

### Ejercicio 2

Implementá el TAD Pila utilizando la siguiente representación:

implement Stack of T where

type Node of T = tuple
    elem : T
    next : pointer to (Node of T)
    end tuple

type Stack of T = pointer to (Node of T)


constructors
    fun empty_stack() ret s : Stack of T
        s:=null
    end fun

    proc push (in e : T, in/out s : Stack of T)
        var aux: pointer to (Node of T)
        alloc(aux)
        aux->elem := e 
        aux->next := s 
        s:=aux 
    end proc

operations
    fun is_empty_stack(s : Stack of T) ret b : Bool
        b:= s=null
    end fun

    {- PRE: not is_empty_stack(s) -}
    fun top(s : Stack of T) ret e : T
        e:=s->elem
    end fun

    {- PRE: not is_empty_stack(s) -}
    proc pop (in/out s : Stack of T)
        var aux: pointer to (Node of T)
        aux:=s 
        s:=s->next
        free(aux)
    end proc



### Ejercicio 3

Completá la implementación del tipo Árbol Binario dada en el teórico, donde utilizamos la siguiente
representación:

implement Tree of T where

type Node of T = tuple
    left: pointer to (Node of T)
    value: T
    right: pointer to (Node of T)
    end tuple

type Tree of T= pointer to (Node of T)

constructors
    fun empty_tree() ret t : Tree of T
        t:=null
    end fun

    fun node (tl : Tree of T, e : T, tr : Tree of T) ret t : Tree of T
        alloc(t)
        t->left:=tl
        t->value:=e 
        t->right:=tr
    end fun

operations
    fun is_empty_tree(t : Tree of T) ret b : Bool
        b:= t=null
    end fun

    fun root(t : Tree of T) ret e : T
        e:=t->e
    end fun
    {- PRE: not is_empty_tree(t) -}

    fun left(t : Tree of T) ret tl : Tree of T
        tl:=t->left
    end fun
    {- PRE: not is_empty_tree(t) -}
    
    fun right(t : Tree of T) ret tl : Tree of T
        tr:=t->right
    end fun
    {- PRE: not is_empty_tree(t) -}

    fun height(t : Tree of T) ret n : Nat
        if is_empty_tree(t) then 
            n:=0
        else
            n:= 1 + max(height(left(t)),height(right(t)))
        fi
    end fun
    
    fun is_path(t : Tree of T, p : Path) ret b : Bool
        var aux: Tree of T
        aux := t
        b := true

        for i := 1 to length(p) do
            if is_empty_tree(aux) then
                b := false
                break
            fi
            if p[i] = "L" then
                aux := left(aux)
            else if p[i] = "R" then
                aux := right(aux)
            else
                b := false
                break
            fi
        od
    end fun

    fun subtree_at(t : Tree of T, p : Path) ret t0 : Tree of T
        var aux: Tree of T
        aux := t
        for i := 1 to length(p) do
            if is_empty_tree(aux) then
                aux := NULL
            fi
            if p[i] = "L" then
                aux := left(aux)
            else if p[i] = "R" then
                aux := right(aux)
            else
                t0 := NULL
                return
            fi
        od
        t0 := aux
    end fun

    fun elem_at(t : Tree of T, p : Path) ret e : T
        var aux: Tree of T
        aux := subtree_at(t, p)
        if is_empty_tree(aux) then
            error("El camino no es válido.")
        fi
        e := root(aux)
    end fun
    {- PRE: is_path(t,p) -}

